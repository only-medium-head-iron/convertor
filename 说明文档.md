### 一、全局说明

- 针对所有规则
  - 条件字段（condition）：即满足条件才会执行该条规则，为空默认为满足条件
  - 排序字段（sort）：多条规则时执行规则的顺序，通过该配置可以定义转换后目标字段的顺序

### 二、转换规则

- 说明：
  - 定义转换后目标的层级，即目标的层级来定义
  - 每个层级需要配置一条转换规则，具体逻辑类似mybatis嵌套查询xml配置
  - 每个子转换规则的源（source）都可以从父级转换规则的源（source）基础上取值，如果source是List，则必须从父级转换规则的源（source）基础上取值，不能直接从最外层params.开始取值
- 举例：
  - 源为多层结构，目标为一层：
  - 源为一层，目标为多层结构：
  - 源为List，目标为List：


### 三、映射规则

#### 1、校验表达式

- 对源字段进行表达式校验
  - 例：源（source）：actQty	校验表达式（validate_expression）：actQty > 0，不满足表达式条件时，会抛出定义的异常信息

#### 2、取值方式

- 尽量使用MAP取值方式，提高性能，一对一映射的可以使用map取值方式

- 包含表达式的只能使用Aviator取值方式

#### 3、接收请求

- 请求映射-REQ

  - 接收请求时存在，应用级别规则，rule_id一般为appCode
  - 请求报文格式（format）：定义接收请求时请求报文格式`format`，默认为`json`，推送请求报文格式由`ApiService`配置决定

  - 服务编码（serviceCode）：**必须配置**，定义具体的接口
  - 其他字段定义见代码`Req`类

- 前置映射-PRE
  - 接收请求时存在
  - 其他字段定义见代码`Pre`类

- 转换映射-DTO
  - 具体报文转换逻辑
  - 通过`rule_id`与具体的转换规则的`id`对应，即每个转换规则都可以配置对应的合并逻辑

#### 4、推送请求

- 转换映射-DTO
  - 具体报文转换逻辑

  - 通过`rule_id`与具体的转换规则的`id`对应，即每个转换规则都可以配置对应的合并逻辑

- 请求头映射-RHD，应用级别规则，rule_id一般为appCode
  - 请求外部时需要放置请求头参数

- 地址栏映射-URL，应用级别规则，rule_id一般为appCode
  - 请求外部时需要拼接在地址栏的参数，即问号后面的参数。例：http://localhost:8080/api?method=deliveryOrder.create

### 四、合并规则

- 说明：对转换时的List进行合并，通过rule_id与具体的转换规则的id对应，即每个转换规则都可以配置对应的合并逻辑

- 简单合并逻辑配置：支持配置分组字段、合并字段、排序字段。（注：目标字段）
  - 例：![image-20241130143704943](images\image-20241130143704943.png)
- 复杂合并逻辑配置：扩展接口`MergeProcessor`，使用时直接继承`AbstractMergeProcessor`即可实现自定义的合并逻辑
  - 例：

### 五、校验规则

- 说明：对转换后的对象进行校验

- 简单校验逻辑配置：配置校验表达式，校验转换后的目标对象是否满足条件，如不满足，则抛出异常，异常信息可自定义，不配置则抛出默认异常”不满足条件【XXX表达式】“
  - 例：![image-20241130143822464](images\image-20241130143822464.png)
- 复杂校验逻辑配置：扩展接口`ValidateProcessor`，使用时直接继承`AbstractValidateProcessor`即可实现自定义的校验逻辑
  - 例：![image-20241130145214332](images\image-20241130145214332.png)


### 时间转换

- 毫秒值转**LocalDateTime**：`LocalDateTimeUtil.of(product_date)`

- 字符串转**LocalDateTime**：`LocalDateTimeUtil.of(string_to_date(orderConfirmTime,'yyyy-MM-dd HH:mm:ss'))`

- 字符串转**Date**：`string_to_date(product_date, 'yyyy-MM-dd : HH:mm:ss')`

- 字符串转毫秒值：`getTime(string_to_date(params.timestamp, 'yyyy-MM-dd HH:mm:ss'))`

- **Date**转字符串：`date_to_string(sysdate(),'yyyy-MM-dd HH:mm:ss')`
- **LocalDate**转字符串：`LocalDateTimeUtil.format(product_date,'yyyy-MM-dd HH:mm:ss')`

### 注意事项
- 推送场景：原入库单与出库单定义的DTO（OutboundHeaderPushReqDTO）字段类型不一致：
  - 入库实际表生产日期、到期日期类型是LocalDate，出库为LocalDateTime。转换json后变为数组: [2019, 11, 30]，source配置为：`StrUtil.join("-", productDate) + ' 00:00:00'`
- 推送场景：原入库单与出库单定义的DTO（InboundDataPushReqDTO）层级结构不一致：入库单多了一层

- 重试场景：双汇ERP重试需要多配置一条重试规则（因为签名在请求体中）
  - 参考：`select * from cim_rule_convert where rule_id = 'SHERP-erp.callback'`
  - 其他推送的重试只需要在现有`转换规则-条件`处配置：`internalRetry == false`

- 新增Handler：如有新增接收 DTO，需要新增字典：`select * from system_dict_type where name = '类全限定名' and type = 'cim_class_name';`